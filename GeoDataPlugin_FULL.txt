===== .gitattributes =====
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain

===== .gitignore =====
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

===== .vscode/launch.json =====
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Rhino 8 - netcore",
      "type": "coreclr",
      "request": "launch",
      "preLaunchTask": "build",
      "program": "",
      "osx": {
        "program": "/Applications/Rhino 8.app/Contents/MacOS/Rhinoceros",
        "args": [
          "-runscript=_Grasshopper"
        ]
      },
      "windows": {
        "program": "C:\\Program Files\\Rhino 8\\System\\Rhino.exe",
        "targetArchitecture": "x86_64",
        "args": "/netcore /runscript=\"_Grasshopper\""
      },
      "env": {
        "RHINO_PACKAGE_DIRS": "${workspaceFolder}/bin/Debug"
      },
      "cwd": "${workspaceFolder}",
      "stopAtEntry": false,
      "console": "internalConsole"
    },
    {
      "name": "Rhino 8 Windows - netfx",
      "type": "clr",
      "request": "launch",
      "preLaunchTask": "build",
      "windows": {
        "program": "C:\\Program Files\\Rhino 8\\System\\Rhino.exe",
        "targetArchitecture": "x86_64",
        "args": "/netfx /runscript=\"_Grasshopper\""
      },
      "env": {
        "RHINO_PACKAGE_DIRS": "${workspaceFolder}/bin/Debug"
      },
      "cwd": "${workspaceFolder}",
      "stopAtEntry": false,
      "console": "internalConsole"
    },
    {
      "name": "Rhino 7 Mac",
      "type": "rhino",
      "request": "launch",
      "preLaunchTask": "build",
      "program": "/Applications/Rhino 7.app/Contents/MacOS/Rhinoceros",
      "args": [
        "-runscript=_Grasshopper"
      ],
      "env": {
        // "RHINO_PLUGIN_PATH": "${workspaceFolder}/bin/Debug/net48/GeoDataPlugin.rhp",
        "GRASSHOPPER_PLUGINS": "${workspaceFolder}/bin/Debug/net48/GeoDataPlugin.gha"
      },
      "cwd": "${workspaceFolder}",
      "console": "internalConsole"
    },
    {
      "name": "Rhino 7 Windows",
      "type": "clr",
      "request": "launch",
      "preLaunchTask": "build",
      "program": "C:\\Program Files\\Rhino 7\\System\\Rhino.exe",
      "targetArchitecture": "x86_64",
      "args": "/runscript=\"_Grasshopper\"",
      "env": {
      },
      "cwd": "${workspaceFolder}",
      "console": "internalConsole"
    },
  ],
  "compounds": []
}

===== .vscode/tasks.json =====
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build",
      "command": "dotnet",
      "type": "shell",
      "args": [
        "build",
        "-clp:NoSummary",
        "${workspaceFolder}/GeoDataPlugin.csproj"
      ],
      "problemMatcher": "$msCompile",
      "presentation": {
        "reveal": "always",
        "clear": true
      },
      "group": "build"
    }
  ]
}

===== Components/AlignmentHelperComponent.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;
using Rhino.Geometry;

namespace GeoDataPlugin.Components
{
    public class AlignmentHelperComponent : GH_Component
    {
        public AlignmentHelperComponent()
          : base("Alignment Helper", "Align",
              "Visualize coordinate origin and alignment reference",
              "GeoData", "Utilities")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("Radius", "R", "Reference radius in meters", GH_ParamAccess.item, 500.0);
            pManager.AddBooleanParameter("Show Grid", "Grid", "Show reference grid", GH_ParamAccess.item, true);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddPointParameter("Origin", "O", "Coordinate origin (0,0,0)", GH_ParamAccess.item);
            pManager.AddCircleParameter("Reference Circle", "C", "Reference radius circle", GH_ParamAccess.item);
            pManager.AddLineParameter("Grid Lines", "G", "Reference grid lines", GH_ParamAccess.list);
            pManager.AddTextParameter("Info", "I", "Alignment information", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            double radius = 500;
            bool showGrid = true;

            if (!DA.GetData(0, ref radius)) return;
            if (!DA.GetData(1, ref showGrid)) return;

            // Origin point
            var origin = Point3d.Origin;
            DA.SetData(0, origin);

            // Reference circle
            var circle = new Circle(Plane.WorldXY, radius);
            DA.SetData(1, circle);

            // Grid lines
            var gridLines = new System.Collections.Generic.List<Line>();

            if (showGrid)
            {
                double step = radius / 5.0; // 5 divisions

                // X-axis lines
                for (double y = -radius; y <= radius; y += step)
                {
                    var p1 = new Point3d(-radius, y, 0);
                    var p2 = new Point3d(radius, y, 0);
                    gridLines.Add(new Line(p1, p2));
                }

                // Y-axis lines
                for (double x = -radius; x <= radius; x += step)
                {
                    var p1 = new Point3d(x, -radius, 0);
                    var p2 = new Point3d(x, radius, 0);
                    gridLines.Add(new Line(p1, p2));
                }

                // Main axes (thicker - can be visualized differently)
                gridLines.Add(new Line(new Point3d(-radius, 0, 0), new Point3d(radius, 0, 0)));
                gridLines.Add(new Line(new Point3d(0, -radius, 0), new Point3d(0, radius, 0)));
            }

            DA.SetDataList(2, gridLines);

            DA.SetData(3, $"Coordinate System:\n" +
                         $"• Origin: (0, 0, 0)\n" +
                         $"• Buildings are positioned relative to search center\n" +
                         $"• Terrain mesh is centered at origin\n" +
                         $"• Both use same local coordinate system\n" +
                         $"• Reference radius: {radius:F1}m");
        }

        public override GH_Exposure Exposure => GH_Exposure.tertiary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("F1234567-89AB-CDEF-0123-456789ABCDEF");
    }
}

===== Components/ApiKeyComponent.cs =====

===== Components/BuildingFilter.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using GeoDataPlugin.Models;

namespace GeoDataPlugin.Components
{
    public class BuildingFilter : GH_Component
    {
        public BuildingFilter()
          : base("Building Filter", "Filter Buildings",
              "Filter building data by type, height, or other properties",
              "GeoData", "Process")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("Building Data", "Data", "Raw building data", GH_ParamAccess.item);
            pManager.AddTextParameter("Type Filter", "Type", "Filter by building type (comma-separated, leave empty for all)", GH_ParamAccess.item, "");
            pManager.AddNumberParameter("Min Height", "MinH", "Minimum height in meters", GH_ParamAccess.item, 0.0);
            pManager.AddNumberParameter("Max Height", "MaxH", "Maximum height in meters (0 = no limit)", GH_ParamAccess.item, 0.0);
            pManager.AddIntegerParameter("Min Levels", "MinL", "Minimum number of levels", GH_ParamAccess.item, 0);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("Filtered Data", "Data", "Filtered building data", GH_ParamAccess.item);
            pManager.AddTextParameter("Info", "I", "Filter results", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Count", "N", "Number after filtering", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            GH_ObjectWrapper wrapper = null;
            string typeFilter = "";
            double minHeight = 0, maxHeight = 0;
            int minLevels = 0;

            if (!DA.GetData(0, ref wrapper)) return;
            if (!DA.GetData(1, ref typeFilter)) return;
            if (!DA.GetData(2, ref minHeight)) return;
            if (!DA.GetData(3, ref maxHeight)) return;
            if (!DA.GetData(4, ref minLevels)) return;

            var dataCollection = wrapper.Value as BuildingDataCollection;
            if (dataCollection == null)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Invalid building data");
                return;
            }

            try
            {
                var filtered = new List<Building>();
                var types = typeFilter.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                    .Select(t => t.Trim().ToLower()).ToList();

                foreach (var building in dataCollection.Buildings)
                {
                    // Type filter
                    if (types.Count > 0)
                    {
                        string bType = (building.BuildingType ?? "yes").ToLower();
                        if (!types.Any(t => bType.Contains(t)))
                            continue;
                    }

                    // Height filter
                    double height = building.GetHeight();
                    if (height < minHeight) continue;
                    if (maxHeight > 0 && height > maxHeight) continue;

                    // Levels filter
                    if (minLevels > 0 && (!building.Levels.HasValue || building.Levels.Value < minLevels))
                        continue;

                    filtered.Add(building);
                }

                var filteredCollection = new BuildingDataCollection
                {
                    Buildings = filtered,
                    OriginLat = dataCollection.OriginLat,
                    OriginLon = dataCollection.OriginLon,
                    BoundingBox = dataCollection.BoundingBox,
                    DownloadTime = dataCollection.DownloadTime
                };

                DA.SetData(0, new GH_ObjectWrapper(filteredCollection));

                string info = $"Filter Results:\n";
                info += $"Input: {dataCollection.Buildings.Count} buildings\n";
                info += $"Output: {filtered.Count} buildings\n";
                info += $"Removed: {dataCollection.Buildings.Count - filtered.Count}\n";

                if (types.Count > 0)
                    info += $"Type filter: {string.Join(", ", types)}\n";
                if (minHeight > 0)
                    info += $"Min height: {minHeight}m\n";
                if (maxHeight > 0)
                    info += $"Max height: {maxHeight}m\n";
                if (minLevels > 0)
                    info += $"Min levels: {minLevels}\n";

                DA.SetData(1, info);
                DA.SetData(2, filtered.Count);

                Message = $"{filtered.Count}/{dataCollection.Buildings.Count}";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(1, $"Error: {ex.Message}");
            }
        }

        public override GH_Exposure Exposure => GH_Exposure.secondary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("1F09A8C0-ECA4-476F-8B2C-44EDC8A91379");
    }
}

===== Components/BuildingProcessor.cs =====
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using GeoDataPlugin.Models;
using GeoDataPlugin.Utils;

namespace GeoDataPlugin.Components
{
    public class BuildingProcessor : GH_Component
    {
        public BuildingProcessor()
          : base("Building Processor", "Process Buildings",
              "Convert raw building data to 3D geometry",
              "GeoData", "Process")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("Building Data", "Data", "Raw building data from OSM Download", GH_ParamAccess.item);
            pManager.AddBooleanParameter("Create Breps", "Breps", "Generate Brep geometry (slower, precise)", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("Create Meshes", "Meshes", "Generate Mesh geometry (faster, approximate)", GH_ParamAccess.item, false);
            pManager.AddNumberParameter("Min Height", "MinH", "Minimum building height (filter)", GH_ParamAccess.item, 0.0);
            pManager.AddNumberParameter("Height Scale", "Scale", "Height multiplier", GH_ParamAccess.item, 1.0);
            pManager.AddBooleanParameter("Process", "Run", "Execute processing", GH_ParamAccess.item, true);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddBrepParameter("Building Breps", "B", "Building breps", GH_ParamAccess.list);
            pManager.AddMeshParameter("Building Meshes", "M", "Building meshes", GH_ParamAccess.list);
            pManager.AddTextParameter("Info", "I", "Processing information", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Count", "N", "Number processed", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            GH_ObjectWrapper wrapper = null;
            bool createBreps = true, createMeshes = false, process = true;
            double minHeight = 0, heightScale = 1.0;

            if (!DA.GetData(0, ref wrapper)) return;
            if (!DA.GetData(1, ref createBreps)) return;
            if (!DA.GetData(2, ref createMeshes)) return;
            if (!DA.GetData(3, ref minHeight)) return;
            if (!DA.GetData(4, ref heightScale)) return;
            if (!DA.GetData(5, ref process)) return;

            if (!process)
            {
                DA.SetData(2, "Set Process=True to generate geometry");
                DA.SetData(3, 0);
                return;
            }

            // Extract data
            var dataCollection = wrapper.Value as BuildingDataCollection;
            if (dataCollection == null)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Invalid building data. Connect to OSM Data Download component.");
                return;
            }

            try
            {
                var stopwatch = Stopwatch.StartNew();
                Message = "Processing...";

                var buildings = dataCollection.Buildings;
                var originLat = dataCollection.OriginLat;
                var originLon = dataCollection.OriginLon;

                // Filter buildings by height
                var filteredBuildings = new List<Building>();
                foreach (var building in buildings)
                {
                    double height = building.GetHeight() * heightScale;
                    if (height >= minHeight)
                    {
                        filteredBuildings.Add(building);
                    }
                }

                List<Brep> breps = null;
                List<Mesh> meshes = null;

                // Create Breps
                if (createBreps)
                {
                    breps = ProcessAsBreps(filteredBuildings, originLat, originLon, heightScale);
                    DA.SetDataList(0, breps);
                }

                // Create Meshes
                if (createMeshes)
                {
                    meshes = ProcessAsMeshes(filteredBuildings, originLat, originLon, heightScale);
                    DA.SetDataList(1, meshes);
                }

                stopwatch.Stop();

                int processedCount = 0;
                if (breps != null) processedCount = breps.Count;
                else if (meshes != null) processedCount = meshes.Count;

                string info = $"✓ Processed in {stopwatch.ElapsedMilliseconds}ms\n";
                info += $"Input: {buildings.Count} buildings\n";
                info += $"Filtered: {filteredBuildings.Count} buildings\n";
                info += $"Output: {processedCount} geometries\n";
                info += $"Height scale: {heightScale:F2}x\n";

                if (filteredBuildings.Count - processedCount > 0)
                {
                    info += $"Skipped: {filteredBuildings.Count - processedCount} (invalid geometry)";
                }

                DA.SetData(2, info);
                DA.SetData(3, processedCount);

                Message = $"{processedCount} buildings";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(2, $"❌ Error: {ex.Message}");
                DA.SetData(3, 0);
                Message = "Error";
            }
        }

        private List<Brep> ProcessAsBreps(List<Building> buildings, double originLat, double originLon, double heightScale)
        {
            // Scale heights
            var scaledBuildings = new List<Building>();
            foreach (var b in buildings)
            {
                var scaled = new Building
                {
                    Id = b.Id,
                    BuildingType = b.BuildingType,
                    Footprint = b.Footprint,
                    Height = b.Height.HasValue ? b.Height.Value * heightScale : (double?)null,
                    Levels = b.Levels
                };
                scaledBuildings.Add(scaled);
            }

            return MeshBuilder.BuildBuildingBreps(scaledBuildings, originLat, originLon);
        }

        private List<Mesh> ProcessAsMeshes(List<Building> buildings, double originLat, double originLon, double heightScale)
        {
            var meshes = new List<Mesh>();

            System.Threading.Tasks.Parallel.For(0, buildings.Count, i =>
            {
                try
                {
                    var building = buildings[i];
                    var mesh = CreateBuildingMesh(building, originLat, originLon, heightScale);
                    if (mesh != null && mesh.IsValid)
                    {
                        lock (meshes)
                        {
                            meshes.Add(mesh);
                        }
                    }
                }
                catch { }
            });

            return meshes;
        }

        private Mesh CreateBuildingMesh(Building building, double originLat, double originLon, double heightScale)
        {
            var points = new List<Point3d>();
            foreach (var geoPoint in building.Footprint)
            {
                points.Add(GeoConverter.GeoToLocal(geoPoint.Lat, geoPoint.Lon, originLat, originLon));
            }

            if (points.Count < 3) return null;

            // Close if needed
            if (points[0].DistanceTo(points[points.Count - 1]) > 0.01)
            {
                points.Add(points[0]);
            }

            double height = building.GetHeight() * heightScale;
            if (height <= 0) height = 10.0;

            var mesh = new Mesh();

            // Add bottom vertices
            int baseIndex = mesh.Vertices.Count;
            foreach (var pt in points)
            {
                mesh.Vertices.Add(pt);
            }

            // Add top vertices
            int topIndex = mesh.Vertices.Count;
            foreach (var pt in points)
            {
                mesh.Vertices.Add(new Point3d(pt.X, pt.Y, pt.Z + height));
            }

            // Add side faces
            for (int i = 0; i < points.Count - 1; i++)
            {
                int v1 = baseIndex + i;
                int v2 = baseIndex + i + 1;
                int v3 = topIndex + i + 1;
                int v4 = topIndex + i;

                mesh.Faces.AddFace(v1, v2, v3, v4);
            }

            // Add top face (triangulate)
            if (points.Count > 3)
            {
                for (int i = 1; i < points.Count - 2; i++)
                {
                    mesh.Faces.AddFace(topIndex, topIndex + i, topIndex + i + 1);
                }
            }

            // Add bottom face
            if (points.Count > 3)
            {
                for (int i = 1; i < points.Count - 2; i++)
                {
                    mesh.Faces.AddFace(baseIndex, baseIndex + i + 1, baseIndex + i);
                }
            }

            mesh.Normals.ComputeNormals();
            mesh.Compact();

            return mesh;
        }

        public override GH_Exposure Exposure => GH_Exposure.primary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("578B9294-F51A-4BDE-9374-A4778A41735C");
    }
}

===== Components/GeoLocationComponent.cs =====
using System;
using Grasshopper.Kernel;

namespace GeoDataPlugin.Components
{
    public class GeoLocationComponent : GH_Component
    {
        public GeoLocationComponent()
          : base("Geo Location", "GeoLoc",
              "Define a geographic location with latitude and longitude",
              "GeoData", "Input")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("Latitude", "Lat", "Latitude (-90 to 90)", GH_ParamAccess.item, 40.7128);
            pManager.AddNumberParameter("Longitude", "Lon", "Longitude (-180 to 180)", GH_ParamAccess.item, -74.0060);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddNumberParameter("Latitude", "Lat", "Latitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Longitude", "Lon", "Longitude", GH_ParamAccess.item);
            pManager.AddTextParameter("Info", "I", "Location info", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            double lat = 0, lon = 0;

            if (!DA.GetData(0, ref lat)) return;
            if (!DA.GetData(1, ref lon)) return;

            // Validate coordinates
            if (lat < -90 || lat > 90)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Latitude must be between -90 and 90");
                return;
            }

            if (lon < -180 || lon > 180)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Longitude must be between -180 and 180");
                return;
            }

            DA.SetData(0, lat);
            DA.SetData(1, lon);
            DA.SetData(2, $"Location: {lat:F6}°, {lon:F6}°");
        }

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("A1234567-89AB-CDEF-0123-456789ABCDEF");
    }
}

===== Components/OSMDataDownloader.cs =====
using GeoDataPlugin.Models;
using GeoDataPlugin.Services;
using GeoDataPlugin.Utils;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using System;
using System.Diagnostics;
using System.Threading.Tasks;

namespace GeoDataPlugin.Components
{
    public class OSMDataDownloader : GH_Component
    {
        private BuildingDataCollection cachedData = null;
        private string lastCacheKey = "";
        private bool isDownloading = false;

        public OSMDataDownloader()
          : base("OSM Data Download", "OSM Download",
              "Download raw building data from OpenStreetMap (no geometry processing)",
              "GeoData", "Data")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("Latitude", "Lat", "Center latitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Longitude", "Lon", "Center longitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Radius", "R", "Radius in meters", GH_ParamAccess.item, 200.0);
            pManager.AddBooleanParameter("Download", "Run", "Execute download", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Clear Cache", "Clear", "Clear cached data", GH_ParamAccess.item, false);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("Building Data", "Data", "Raw building data collection", GH_ParamAccess.item);
            pManager.AddTextParameter("Summary", "Info", "Data summary", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Count", "N", "Number of buildings", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            double lat = 0, lon = 0, radius = 200;
            bool download = false, clear = false;

            if (!DA.GetData(0, ref lat)) return;
            if (!DA.GetData(1, ref lon)) return;
            if (!DA.GetData(2, ref radius)) return;
            if (!DA.GetData(3, ref download)) return;
            if (!DA.GetData(4, ref clear)) return;

            string cacheKey = $"{lat:F6}_{lon:F6}_{radius:F1}";

            if (clear)
            {
                cachedData = null;
                lastCacheKey = "";
                DA.SetData(1, "Cache cleared. Set Download=True to fetch data.");
                DA.SetData(2, 0);
                return;
            }

            // Return cached data if available
            if (cachedData != null && cacheKey == lastCacheKey)
            {
                DA.SetData(0, new GH_ObjectWrapper(cachedData));
                DA.SetData(1, "✓ Cached Data\n" + cachedData.GetSummary());
                DA.SetData(2, cachedData.Buildings.Count);
                return;
            }

            if (!download)
            {
                if (cachedData != null)
                {
                    DA.SetData(0, new GH_ObjectWrapper(cachedData));
                    DA.SetData(1, "✓ Cached\n" + cachedData.GetSummary());
                    DA.SetData(2, cachedData.Buildings.Count);
                }
                else
                {
                    DA.SetData(1, "Set Download=True to fetch building data from OpenStreetMap");
                    DA.SetData(2, 0);
                }
                return;
            }

            if (isDownloading)
            {
                DA.SetData(1, "Downloading... Please wait.");
                return;
            }

            // Validate inputs
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Invalid coordinates");
                return;
            }

            try
            {
                isDownloading = true;
                var stopwatch = Stopwatch.StartNew();

                var bbox = GeoConverter.CreateBBox(lat, lon, radius);

                Message = "Downloading...";

                var task = Task.Run(async () => await OverpassService.GetBuildingsAsync(bbox));

                if (!task.Wait(TimeSpan.FromSeconds(65)))
                {
                    throw new Exception("Download timeout. Try reducing radius.");
                }

                var buildings = task.Result;

                stopwatch.Stop();

                if (buildings.Count == 0)
                {
                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "No buildings found");
                    DA.SetData(1, "No buildings found in this area");
                    DA.SetData(2, 0);
                    return;
                }

                // Create data collection
                var dataCollection = new BuildingDataCollection
                {
                    Buildings = buildings,
                    OriginLat = lat,
                    OriginLon = lon,
                    BoundingBox = bbox,
                    DownloadTime = DateTime.Now
                };

                cachedData = dataCollection;
                lastCacheKey = cacheKey;

                DA.SetData(0, new GH_ObjectWrapper(dataCollection));
                DA.SetData(1, $"✓ Downloaded in {stopwatch.ElapsedMilliseconds}ms\n" + dataCollection.GetSummary());
                DA.SetData(2, buildings.Count);

                Message = $"{buildings.Count} buildings";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(1, $"❌ Error: {ex.Message}");
                DA.SetData(2, 0);
                Message = "Error";
            }
            finally
            {
                isDownloading = false;
            }
        }

        public override GH_Exposure Exposure => GH_Exposure.primary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("AEDF3B70-2640-41E8-BADA-813A9080BD13");
    }
}

===== Components/QuickTestComponent.cs =====
using System;
using System.Collections.Generic;
using Grasshopper.Kernel;
using Rhino.Geometry;

namespace GeoDataPlugin.Components
{
    public class QuickTestComponent : GH_Component
    {
        public QuickTestComponent()
          : base("Quick Test Buildings", "TestBuildings",
              "Generate sample buildings for testing (no API call needed)",
              "GeoData", "Testing")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddIntegerParameter("Count", "N", "Number of sample buildings", GH_ParamAccess.item, 5);
            pManager.AddNumberParameter("Size", "S", "Average building size", GH_ParamAccess.item, 20.0);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddBrepParameter("Buildings", "B", "Sample building breps", GH_ParamAccess.list);
            pManager.AddTextParameter("Info", "I", "Information", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            int count = 5;
            double size = 20.0;

            if (!DA.GetData(0, ref count)) return;
            if (!DA.GetData(1, ref size)) return;

            if (count < 1 || count > 100)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Count must be between 1 and 100");
                return;
            }

            var breps = new List<Brep>();
            var random = new Random(42); // Fixed seed for consistency

            for (int i = 0; i < count; i++)
            {
                try
                {
                    // Random position in a grid
                    double x = (i % 5) * size * 2.5;
                    double y = (i / 5) * size * 2.5;

                    // Random building dimensions
                    double width = size * (0.7 + random.NextDouble() * 0.6);
                    double depth = size * (0.7 + random.NextDouble() * 0.6);
                    double height = 10 + random.NextDouble() * 30;

                    // Create footprint rectangle
                    var plane = Plane.WorldXY;
                    plane.Origin = new Point3d(x, y, 0);

                    var rect = new Rectangle3d(plane, width, depth);
                    var baseCurve = rect.ToNurbsCurve();

                    // Create base surface
                    var baseBreps = Brep.CreatePlanarBreps(baseCurve, 0.01);
                    if (baseBreps == null || baseBreps.Length == 0) continue;

                    // Extrude upward
                    var surface = Surface.CreateExtrusion(baseCurve, new Vector3d(0, 0, height));
                    if (surface != null)
                    {
                        var building = surface.ToBrep();
                        if (building != null && building.IsValid)
                        {
                            // Cap the top and bottom
                            building = building.CapPlanarHoles(0.01);
                            if (building != null && building.IsValid && building.IsSolid)
                            {
                                breps.Add(building);
                            }
                            else
                            {
                                // Try alternative method
                                var box = new Box(plane, new Interval(0, width), new Interval(0, depth), new Interval(0, height));
                                var boxBrep = box.ToBrep();
                                if (boxBrep != null && boxBrep.IsValid)
                                {
                                    breps.Add(boxBrep);
                                }
                            }
                        }
                    }
                }
                catch
                {
                    // Skip failed buildings
                    continue;
                }
            }

            if (breps.Count == 0)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Failed to generate buildings");
            }

            DA.SetDataList(0, breps);
            DA.SetData(1, $"Generated {breps.Count} sample buildings. Use this to test before downloading real data.");
        }

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("C1234567-89AB-CDEF-0123-456789ABCDEF");
    }
}

===== Components/StreetDataDownloader.cs =====
using GeoDataPlugin.Models;
using GeoDataPlugin.Services;
using GeoDataPlugin.Utils;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;

namespace GeoDataPlugin.Components
{
    public class StreetDataDownloader : GH_Component
    {
        private StreetDataCollection cachedData = null;
        private string lastCacheKey = "";
        private bool isDownloading = false;

        public StreetDataDownloader()
          : base("OSM Street Download", "Street Download",
              "Download raw street/road data from OpenStreetMap",
              "GeoData", "Data")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("Latitude", "Lat", "Center latitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Longitude", "Lon", "Center longitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Radius", "R", "Radius in meters", GH_ParamAccess.item, 500.0);
            pManager.AddBooleanParameter("Include Major", "Major", "Include highways/main roads", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("Include Residential", "Resid", "Include residential streets", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("Include Service", "Serv", "Include service roads", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Download", "Run", "Execute download", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Clear Cache", "Clear", "Clear cached data", GH_ParamAccess.item, false);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("Street Data", "Data", "Raw street data collection", GH_ParamAccess.item);
            pManager.AddTextParameter("Summary", "Info", "Data summary", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Count", "N", "Number of streets", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            double lat = 0, lon = 0, radius = 500;
            bool includeMajor = true, includeResidential = true, includeService = false;
            bool download = false, clear = false;

            if (!DA.GetData(0, ref lat)) return;
            if (!DA.GetData(1, ref lon)) return;
            if (!DA.GetData(2, ref radius)) return;
            if (!DA.GetData(3, ref includeMajor)) return;
            if (!DA.GetData(4, ref includeResidential)) return;
            if (!DA.GetData(5, ref includeService)) return;
            if (!DA.GetData(6, ref download)) return;
            if (!DA.GetData(7, ref clear)) return;

            string cacheKey = $"{lat:F6}_{lon:F6}_{radius:F1}_{includeMajor}_{includeResidential}_{includeService}";

            if (clear)
            {
                cachedData = null;
                lastCacheKey = "";
                DA.SetData(1, "Cache cleared. Set Download=True to fetch data.");
                DA.SetData(2, 0);
                return;
            }

            if (cachedData != null && cacheKey == lastCacheKey)
            {
                DA.SetData(0, new GH_ObjectWrapper(cachedData));
                DA.SetData(1, "✓ Cached Data\n" + cachedData.GetSummary());
                DA.SetData(2, cachedData.Streets.Count);
                return;
            }

            if (!download)
            {
                if (cachedData != null)
                {
                    DA.SetData(0, new GH_ObjectWrapper(cachedData));
                    DA.SetData(1, "✓ Cached\n" + cachedData.GetSummary());
                    DA.SetData(2, cachedData.Streets.Count);
                }
                else
                {
                    DA.SetData(1, "Set Download=True to fetch street data from OpenStreetMap");
                    DA.SetData(2, 0);
                }
                return;
            }

            if (isDownloading)
            {
                DA.SetData(1, "Downloading...");
                return;
            }

            try
            {
                isDownloading = true;
                var stopwatch = Stopwatch.StartNew();

                var bbox = GeoConverter.CreateBBox(lat, lon, radius);

                var filter = new StreetFilter
                {
                    IncludeMotorways = includeMajor,
                    IncludeTrunks = includeMajor,
                    IncludePrimary = includeMajor,
                    IncludeSecondary = includeMajor,
                    IncludeTertiary = includeResidential,
                    IncludeResidential = includeResidential,
                    IncludeService = includeService,
                    IncludePedestrian = false,
                    IncludePaths = false
                };

                Message = "Downloading...";

                var task = Task.Run(async () => await StreetsService.GetStreetsAsync(bbox, filter));

                if (!task.Wait(TimeSpan.FromSeconds(65)))
                {
                    throw new Exception("Download timeout. Try reducing radius.");
                }

                var streets = task.Result;

                stopwatch.Stop();

                if (streets.Count == 0)
                {
                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "No streets found");
                    DA.SetData(1, "No streets found in this area");
                    DA.SetData(2, 0);
                    return;
                }

                var dataCollection = new StreetDataCollection
                {
                    Streets = streets,
                    OriginLat = lat,
                    OriginLon = lon,
                    BoundingBox = bbox,
                    DownloadTime = DateTime.Now
                };

                cachedData = dataCollection;
                lastCacheKey = cacheKey;

                DA.SetData(0, new GH_ObjectWrapper(dataCollection));
                DA.SetData(1, $"✓ Downloaded in {stopwatch.ElapsedMilliseconds}ms\n" + dataCollection.GetSummary());
                DA.SetData(2, streets.Count);

                Message = $"{streets.Count} streets";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(1, $"❌ Error: {ex.Message}");
                DA.SetData(2, 0);
                Message = "Error";
            }
            finally
            {
                isDownloading = false;
            }
        }

        public override GH_Exposure Exposure => GH_Exposure.primary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("9B904D25-D1CF-4C4B-A47F-7E460F83A71C");
    }
}

===== Components/StreetProcessor.cs =====
using GeoDataPlugin.Models;
using GeoDataPlugin.Utils;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GeoDataPlugin.Components
{
    public class StreetProcessor : GH_Component
    {
        public StreetProcessor()
          : base("Street Processor", "Process Streets",
              "Convert raw street data to geometry (centerlines and/or surfaces)",
              "GeoData", "Process")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddGenericParameter("Street Data", "Data", "Raw street data from Street Download", GH_ParamAccess.item);
            pManager.AddBooleanParameter("Create Centerlines", "Lines", "Generate centerline curves", GH_ParamAccess.item, true);
            pManager.AddBooleanParameter("Create Surfaces", "Surf", "Generate 3D road surfaces", GH_ParamAccess.item, false);
            pManager.AddNumberParameter("Width Scale", "WScale", "Road width multiplier", GH_ParamAccess.item, 1.0);
            pManager.AddNumberParameter("Simplify Tolerance", "Tol", "Simplify curves (0 = no simplification)", GH_ParamAccess.item, 0.0);
            pManager.AddBooleanParameter("Process", "Run", "Execute processing", GH_ParamAccess.item, true);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Centerlines", "C", "Street centerline curves", GH_ParamAccess.list);
            pManager.AddBrepParameter("Surfaces", "S", "Road surface breps", GH_ParamAccess.list);
            pManager.AddTextParameter("Names", "N", "Street names", GH_ParamAccess.list);
            pManager.AddTextParameter("Info", "I", "Processing information", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Count", "Cnt", "Number processed", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            GH_ObjectWrapper wrapper = null;
            bool createCenterlines = true, createSurfaces = false, process = true;
            double widthScale = 1.0, simplifyTol = 0.0;

            if (!DA.GetData(0, ref wrapper)) return;
            if (!DA.GetData(1, ref createCenterlines)) return;
            if (!DA.GetData(2, ref createSurfaces)) return;
            if (!DA.GetData(3, ref widthScale)) return;
            if (!DA.GetData(4, ref simplifyTol)) return;
            if (!DA.GetData(5, ref process)) return;

            if (!process)
            {
                DA.SetData(3, "Set Process=True to generate geometry");
                DA.SetData(4, 0);
                return;
            }

            var dataCollection = wrapper.Value as StreetDataCollection;
            if (dataCollection == null)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Invalid street data. Connect to Street Download component.");
                return;
            }

            try
            {
                var stopwatch = Stopwatch.StartNew();
                Message = "Processing...";

                var streets = dataCollection.Streets;
                var originLat = dataCollection.OriginLat;
                var originLon = dataCollection.OriginLon;

                var centerlines = new List<Curve>();
                var surfaces = new List<Brep>();
                var names = new List<string>();

                foreach (var street in streets)
                {
                    var points = new List<Point3d>();
                    foreach (var geoPoint in street.Centerline)
                    {
                        points.Add(GeoConverter.GeoToLocal(geoPoint.Lat, geoPoint.Lon, originLat, originLon));
                    }

                    if (points.Count < 2) continue;

                    // Create centerline
                    var polyline = new Polyline(points);
                    var curve = polyline.ToNurbsCurve();

                    if (curve == null || !curve.IsValid) continue;

                    // Simplify if requested
                    if (simplifyTol > 0)
                    {
                        Curve simplified = curve.Simplify(CurveSimplifyOptions.All, simplifyTol, 0.1);
                        if (simplified != null)
                            curve = simplified.ToNurbsCurve();
                    }

                    if (createCenterlines)
                    {
                        centerlines.Add(curve);
                        names.Add(street.Name ?? "Unnamed");
                    }

                    // Create surface if requested
                    if (createSurfaces)
                    {
                        double width = street.Width * widthScale;
                        var surface = CreateRoadSurface(curve, width);
                        if (surface != null)
                        {
                            surfaces.Add(surface);
                        }
                    }
                }

                stopwatch.Stop();

                DA.SetDataList(0, centerlines);
                DA.SetDataList(1, surfaces);
                DA.SetDataList(2, names);

                string info = $"✓ Processed in {stopwatch.ElapsedMilliseconds}ms\n";
                info += $"Input: {streets.Count} streets\n";
                info += $"Centerlines: {centerlines.Count}\n";
                info += $"Surfaces: {surfaces.Count}\n";
                if (simplifyTol > 0)
                    info += $"Simplified with tolerance: {simplifyTol}\n";

                DA.SetData(3, info);
                DA.SetData(4, centerlines.Count);

                Message = $"{centerlines.Count} streets";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(3, $"❌ Error: {ex.Message}");
                DA.SetData(4, 0);
                Message = "Error";
            }
        }

        private Brep CreateRoadSurface(Curve centerline, double width)
        {
            try
            {
                double halfWidth = width / 2.0;

                var leftCurve = centerline.Offset(Plane.WorldXY, halfWidth, 0.01, CurveOffsetCornerStyle.Sharp);
                var rightCurve = centerline.Offset(Plane.WorldXY, -halfWidth, 0.01, CurveOffsetCornerStyle.Sharp);

                if (leftCurve != null && leftCurve.Length > 0 && rightCurve != null && rightCurve.Length > 0)
                {
                    var loft = Brep.CreateFromLoft(
                        new Curve[] { leftCurve[0], rightCurve[0] },
                        Point3d.Unset,
                        Point3d.Unset,
                        LoftType.Straight,
                        false
                    );

                    if (loft != null && loft.Length > 0)
                    {
                        return loft[0];
                    }
                }
            }
            catch { }

            return null;
        }

        public override GH_Exposure Exposure => GH_Exposure.primary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("D8649244-A614-45C7-B7C1-A35B884169B6");
    }
}

===== Components/TerrainComponent.cs =====
using System;
using System.Threading.Tasks;
using System.Diagnostics;
using Grasshopper.Kernel;
using Rhino.Geometry;
using GeoDataPlugin.Models;
using GeoDataPlugin.Services;
using GeoDataPlugin.Utils;

namespace GeoDataPlugin.Components
{
    public class TerrainComponent : GH_Component
    {
        private Mesh cachedMesh = null;
        private string lastCacheKey = "";
        private bool isProcessing = false;

        public TerrainComponent()
          : base("Terrain Mesh", "Terrain",
              "Download elevation data and create terrain mesh using REAL satellite data",
              "GeoData", "Import")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddNumberParameter("Latitude", "Lat", "Center latitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Longitude", "Lon", "Center longitude", GH_ParamAccess.item);
            pManager.AddNumberParameter("Radius", "R", "Radius in meters", GH_ParamAccess.item, 1000.0);
            pManager.AddIntegerParameter("Grid Size", "Grid", "Number of sample points (10-100, higher=more detail)", GH_ParamAccess.item, 30);
            pManager.AddNumberParameter("Z Scale", "Z", "Vertical exaggeration factor", GH_ParamAccess.item, 1.0);
            pManager.AddBooleanParameter("Run", "Run", "Execute download", GH_ParamAccess.item, false);
            pManager.AddBooleanParameter("Reset Cache", "Reset", "Clear cached data", GH_ParamAccess.item, false);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddMeshParameter("Terrain", "T", "Terrain mesh", GH_ParamAccess.item);
            pManager.AddTextParameter("Info", "I", "Information", GH_ParamAccess.item);
            pManager.AddNumberParameter("Min Elevation", "Min", "Minimum elevation (m)", GH_ParamAccess.item);
            pManager.AddNumberParameter("Max Elevation", "Max", "Maximum elevation (m)", GH_ParamAccess.item);
            pManager.AddRectangleParameter("Bounds", "B", "Terrain boundary rectangle", GH_ParamAccess.item);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            double lat = 0, lon = 0, radius = 1000, zScale = 1.0;
            int gridSize = 30;
            bool run = false, reset = false;

            if (!DA.GetData(0, ref lat)) return;
            if (!DA.GetData(1, ref lon)) return;
            if (!DA.GetData(2, ref radius)) return;
            if (!DA.GetData(3, ref gridSize)) return;
            if (!DA.GetData(4, ref zScale)) return;
            if (!DA.GetData(5, ref run)) return;
            if (!DA.GetData(6, ref reset)) return;

            // Validate grid size
            if (gridSize < 10 || gridSize > 100)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Grid size should be 10-100. Using 30.");
                gridSize = 30;
            }

            string cacheKey = $"{lat:F6}_{lon:F6}_{radius:F1}_{gridSize}_{zScale:F2}";

            if (reset)
            {
                cachedMesh = null;
                lastCacheKey = "";
                DA.SetData(1, "Cache cleared. Set Run to True to download.");
                return;
            }

            if (cachedMesh != null && cacheKey == lastCacheKey)
            {
                DA.SetData(0, cachedMesh);
                DA.SetData(1, "✓ Using cached terrain (Set Reset=True to clear)");
                return;
            }

            if (!run)
            {
                if (cachedMesh != null)
                {
                    DA.SetData(0, cachedMesh);
                    DA.SetData(1, "✓ Cached terrain. Set Run=True to re-download.");
                }
                else
                {
                    DA.SetData(1, "Set Run to True to download REAL terrain data.\n\nUsing Open Topo Data API (free, no key needed!)\nData source: SRTM 30m global elevation");
                }
                return;
            }

            if (isProcessing)
            {
                DA.SetData(1, "Processing... Please wait.");
                return;
            }

            if (lat < -90 || lat > 90 || lon < -180 || lon > 180)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Invalid coordinates");
                return;
            }

            if (radius > 10000)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning,
                    "Large radius (>10km) will be slow due to API rate limits.");
            }

            try
            {
                isProcessing = true;
                var stopwatch = Stopwatch.StartNew();

                var bbox = GeoConverter.CreateBBox(lat, lon, radius);

                Message = $"Downloading {gridSize}x{gridSize} points...";

                // Download REAL elevation data
                var task = Task.Run(async () => await OpenTopoService.GetElevationAsync(bbox, gridSize));

                if (!task.Wait(TimeSpan.FromSeconds(300))) // Longer timeout for API calls
                {
                    throw new Exception("Download timeout. Try reducing grid size or radius.");
                }

                var elevationGrid = task.Result;

                Message = "Building mesh...";

                // Apply Z scale
                var scaledElevations = new double[elevationGrid.Rows, elevationGrid.Cols];
                for (int i = 0; i < elevationGrid.Rows; i++)
                {
                    for (int j = 0; j < elevationGrid.Cols; j++)
                    {
                        scaledElevations[i, j] = elevationGrid.Elevations[i, j] * zScale;
                    }
                }

                // Calculate origin to align with buildings
                double meshWidth = elevationGrid.Cols * elevationGrid.CellSize;
                double meshHeight = elevationGrid.Rows * elevationGrid.CellSize;

                // Center the terrain mesh at origin
                Point3d origin = new Point3d(-meshWidth / 2.0, -meshHeight / 2.0, 0);

                var mesh = MeshBuilder.BuildTerrainMesh(
                    scaledElevations,
                    elevationGrid.CellSize,
                    origin
                );

                stopwatch.Stop();

                cachedMesh = mesh;
                lastCacheKey = cacheKey;

                DA.SetData(0, mesh);
                DA.SetData(1, $"✓ REAL terrain downloaded in {stopwatch.ElapsedMilliseconds}ms!\n" +
                             $"Grid: {elevationGrid.Rows}×{elevationGrid.Cols} sample points\n" +
                             $"Data source: SRTM 30m (Open Topo Data API)\n" +
                             $"Area: {meshWidth:F1}m × {meshHeight:F1}m\n" +
                             $"Elevation range: {elevationGrid.MinElevation * zScale:F1}m to {elevationGrid.MaxElevation * zScale:F1}m");
                DA.SetData(2, elevationGrid.MinElevation * zScale);
                DA.SetData(3, elevationGrid.MaxElevation * zScale);

                // Create boundary rectangle for visualization
                var plane = Plane.WorldXY;
                var bounds = new Rectangle3d(plane, new Interval(-meshWidth / 2, meshWidth / 2), new Interval(-meshHeight / 2, meshHeight / 2));
                DA.SetData(4, bounds);

                Message = $"{elevationGrid.Rows}×{elevationGrid.Cols} REAL";
            }
            catch (Exception ex)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Error, ex.Message);
                DA.SetData(1, $"❌ Error: {ex.Message}\n\nTip: Try smaller grid size (20-30) or smaller radius.");
                Message = "Error";
            }
            finally
            {
                isProcessing = false;
            }
        }

        public override GH_Exposure Exposure => GH_Exposure.primary;

        protected override System.Drawing.Bitmap Icon => null;

        public override Guid ComponentGuid => new Guid("32E9EF54-BA22-4FFF-9F20-5E3CE18CD843");
    }
}

===== GeoDataComponent.cs =====
using Grasshopper;
using Grasshopper.Kernel;
using Rhino.Geometry;
using System;
using System.Collections.Generic;

namespace GeoDataPlugin
{
    public class GeoDataComponent : GH_Component
    {
        /// <summary>
        /// Each implementation of GH_Component must provide a public 
        /// constructor without any arguments.
        /// Category represents the Tab in which the component will appear, 
        /// Subcategory the panel. If you use non-existing tab or panel names, 
        /// new tabs/panels will automatically be created.
        /// </summary>
        public GeoDataComponent()
          : base("GeoDataComponent", "Nickname",
            "Description",
            "Category", "Subcategory")
        {
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object can be used to retrieve data from input parameters and 
        /// to store data in output parameters.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
        }

        /// <summary>
        /// Provides an Icon for every component that will be visible in the User Interface.
        /// Icons need to be 24x24 pixels.
        /// You can add image files to your project resources and access them like this:
        /// return Resources.IconForThisComponent;
        /// </summary>
        protected override System.Drawing.Bitmap Icon => null;

        /// <summary>
        /// Each component must have a unique Guid to identify it. 
        /// It is vital this Guid doesn't change otherwise old ghx files 
        /// that use the old ID will partially fail during loading.
        /// </summary>
        public override Guid ComponentGuid => new Guid("f9ed8a6b-bb51-471a-8697-76deb1c5b51e");
    }
}

===== GeoDataPlugin.csproj =====
<Project Sdk="Microsoft.NET.Sdk">
	
  <PropertyGroup>
    <!-- Select the framework(s) you wish to target.
        Rhino 6: net45
        Rhino 7: net48
        Rhino 8 Windows: net48, net7.0, net7.0-windows, net7.0-windows10.0.22000.0, etc
        Rhino 8 Mac: net7.0, net7.0-macos, net7.0-macos12.0, etc
    -->
    <TargetFrameworks>net7.0-windows;net7.0;net48</TargetFrameworks>
    <EnableDynamicLoading>true</EnableDynamicLoading>
    <TargetExt>.gha</TargetExt>
    <NoWarn>NU1701;NETSDK1086</NoWarn>
    <EnableWindowsTargeting>true</EnableWindowsTargeting>
  </PropertyGroup>
  
  <PropertyGroup>
    <!-- Specifies information for Assembly and Yak -->
    <Version>1.0</Version>
    <Title>GeoDataPlugin</Title>
    <Company>GeoDataPlugin Authors</Company>
    <Description>Description of GeoDataPlugin</Description>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Grasshopper" Version="7.0.20314.3001" Condition="$(TargetFramework) == 'net48'" ExcludeAssets="runtime" />
    <PackageReference Include="Grasshopper" Version="8.0.23304.9001" Condition="!$(TargetFramework.StartsWith('net4'))" ExcludeAssets="runtime" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />
    <PackageReference Include="RestSharp" Version="113.1.0" />
    <PackageReference Include="System.Net.Http" Version="4.3.4" />
  </ItemGroup>
  
  <!-- For Windows only builds -->
  <PropertyGroup Condition="$(TargetFramework.Contains('-windows')) or $(TargetFramework.StartsWith('net4'))">
    <UseWindowsForms>true</UseWindowsForms>
  </PropertyGroup>

  <!-- Reference WinForms for .NET 7.0 on macOS -->
  <ItemGroup Condition="!($(TargetFramework.Contains('-windows')) or $(TargetFramework.StartsWith('net4')))">
    <!-- Rhino 8.11 and later you can use this -->
    <!-- <FrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" /> -->
    
    <!-- Rhino 8.10 and earlier -->
    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies.net48" Version="1.0.3" ExcludeAssets="all" GeneratePathProperty="true" />
    <Reference Include="$(PkgMicrosoft_NETFramework_ReferenceAssemblies_net48)\build\.NETFramework\v4.8\System.Windows.Forms.dll" Private="False" />
    <PackageReference Include="System.Drawing.Common" Version="7.0.0" ExcludeAssets="runtime" />
  </ItemGroup>

  <Target Name="CopyPdbForMonoDebugging" AfterTargets="AfterBuild">
    <!-- Enable debugging in Rhino 6/7 on Mac -->
    <Copy SourceFiles="$(TargetDir)$(TargetName).pdb" DestinationFiles="$(TargetDir)$(TargetName).gha.pdb" Condition="$([MSBuild]::IsOSPlatform(OSX)) and $(TargetFramework.StartsWith('net4')) and Exists('$(TargetDir)$(TargetName).pdb')" />
  </Target>

</Project>

===== GeoDataPlugin.slnx =====
<Solution>
  <Project Path="GeoDataPlugin.csproj" />
</Solution>

===== GeoDataPluginInfo.cs =====
using Grasshopper;
using Grasshopper.Kernel;
using System;
using System.Drawing;

namespace GeoDataPlugin
{
    public class GeoDataPluginInfo : GH_AssemblyInfo
    {
        public override string Name => "GeoDataPlugin";

        //Return a 24x24 pixel bitmap to represent this GHA library.
        public override Bitmap Icon => null;

        //Return a short string describing the purpose of this GHA library.
        public override string Description => "Import geospatial data from OpenStreetMap and terrain APIs to create 3D models";

        public override Guid Id => new Guid("c98d0a22-74a0-4f0b-b223-2d1b261524d2");

        //Return a string identifying you or your company.
        public override string AuthorName => "Asem Abdelsalam";

        //Return a string representing your preferred contact details.
        public override string AuthorContact => "assemmohamed1000@gmail.com";

        //Return a string representing the version.  This returns the same version as the assembly.
        public override string AssemblyVersion => GetType().Assembly.GetName().Version.ToString();
    }
}

===== LICENSE.txt =====
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===== Models/Building.cs =====
using System.Collections.Generic;

namespace GeoDataPlugin.Models
{
    public class Building
    {
        public string Id { get; set; }
        public List<GeoPoint> Footprint { get; set; }
        public double? Height { get; set; }
        public int? Levels { get; set; }
        public string BuildingType { get; set; }

        public Building()
        {
            Footprint = new List<GeoPoint>();
        }

        public double GetHeight()
        {
            if (Height.HasValue) return Height.Value;
            if (Levels.HasValue) return Levels.Value * 3.5; // 3.5m is floor height
            return 10.0;  // Default value for height
        }
    }
}


===== Models/BuildingDataCollection.cs =====
using System;
using System.Collections.Generic;
using System.Linq;

namespace GeoDataPlugin.Models
{
    // Container for raw OSM building data (serializable)
    [Serializable]
    public class BuildingDataCollection
    {
        public List<Building> Buildings { get; set; }
        public double OriginLat { get; set; }
        public double OriginLon { get; set; }
        public GeoBoundingBox BoundingBox { get; set; }
        public DateTime DownloadTime { get; set; }

        public BuildingDataCollection()
        {
            Buildings = new List<Building>();
            DownloadTime = DateTime.Now;
        }

        public string GetSummary()
        {
            var typeGroups = Buildings.GroupBy(b => b.BuildingType ?? "unknown");
            var summary = $"Buildings: {Buildings.Count}\n";
            summary += $"Origin: ({OriginLat:F6}, {OriginLon:F6})\n";
            summary += $"Downloaded: {DownloadTime:g}\n";
            summary += "Types:\n";
            foreach (var group in typeGroups.OrderByDescending(g => g.Count()).Take(5))
            {
                summary += $"  {group.Key}: {group.Count()}\n";
            }
            return summary;
        }
    }
}

===== Models/ElevationGrid.cs =====
namespace GeoDataPlugin.Models
{
    // Elevation grid data
    public class ElevationGrid
    {
        public double[,] Elevations { get; set; }
        public int Rows { get; set; }
        public int Cols { get; set; }
        public double CellSize { get; set; }
        public GeoBoundingBox BoundingBox { get; set; }

        public double MinElevation
        {
            get
            {
                double min = double.MaxValue;
                for (int i = 0; i < Rows; i++)
                {
                    for (int j = 0; j < Cols; j++)
                    {
                        if (Elevations[i, j] < min) min = Elevations[i, j];
                    }
                }
                return min;
            }
        }

        public double MaxElevation
        {
            get
            {
                double max = double.MinValue;
                for (int i = 0; i < Rows; i++)
                {
                    for (int j = 0; j < Cols; j++)
                    {
                        if (Elevations[i, j] > max) max = Elevations[i, j];
                    }
                }
                return max;
            }
        }
    }
}

===== Models/GeoBoundingBox.cs =====
using GeoDataPlugin.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GeoDataPlugin.Models
{
    /// <summary>
    /// Represents a rectangular geographic area defined by its southern, western, northern, and eastern boundaries in
    /// latitude and longitude coordinates.
    /// </summary>
    /// <remarks>Use this class to specify or query a bounding box for geographic operations, such as spatial
    /// searches or map rendering. The boundaries are expressed in WGS84 coordinates. The class provides properties to
    /// access the center point of the box and methods to estimate its width and height in meters.</remarks>
    public class GeoBoundingBox
    {
        //coordinates, in latitude & longitude
        public double South { get; set; }
        public double West { get; set; }
        public double North { get; set; }
        public double East { get; set; }

        public GeoBoundingBox(double south, double west, double north, double east)
        {
            South = south;
            West = west;
            North = north;
            East = east;
        }
        // CenterLat & CenterLon 
        public double CenterLat => (South + North) / 2.0;
        public double CenterLon => (West + East) / 2.0;

        // Calculate approximate width in meters
        public double WidthMeters()
        {
            return GeoConverter.HaversineDistance(South, West, South, East);
        }

        // Calculate approximate height in meters
        public double HeightMeters()
        {
            return GeoConverter.HaversineDistance(South, West, North, West);
        }        
    }
}

===== Models/GeoPoint.cs =====
namespace GeoDataPlugin.Models
{
    // Represents a single geographic point in WGS84 coordinates.
    public class GeoPoint
    {
        public double Lat { get; set; }
        public double Lon { get; set; } 
        public GeoPoint(double lat, double lon)
        {
            Lat = lat;
            Lon = lon;
        }
    }
}

===== Models/Street.cs =====
using System.Collections.Generic;

namespace GeoDataPlugin.Models
{
    // Street/Road data from OSM
    public class Street
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public string Type { get; set; }
        public List<GeoPoint> Centerline { get; set; }
        public double Width { get; set; }
        public int? Lanes { get; set; }

        public Street()
        {
            Centerline = new List<GeoPoint>();
        }
    }
}

===== Models/StreetDataCollection.cs =====
using GeoDataPlugin.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace GeoDataPlugin.Models
{
    // Container for raw OSM street data (serializable)
    [Serializable]
    public class StreetDataCollection
    {
        public List<Street> Streets { get; set; }
        public double OriginLat { get; set; }
        public double OriginLon { get; set; }
        public GeoBoundingBox BoundingBox { get; set; }
        public DateTime DownloadTime { get; set; }

        public StreetDataCollection()
        {
            Streets = new List<Street>();
            DownloadTime = DateTime.Now;
        }

        public string GetSummary()
        {
            var typeGroups = Streets.GroupBy(s => s.Type ?? "unknown");
            var summary = $"Streets: {Streets.Count}\n";
            summary += $"Origin: ({OriginLat:F6}, {OriginLon:F6})\n";
            summary += $"Downloaded: {DownloadTime:g}\n";

            double totalLength = 0;
            foreach (var street in Streets)
            {
                for (int i = 0; i < street.Centerline.Count - 1; i++)
                {
                    var p1 = street.Centerline[i];
                    var p2 = street.Centerline[i + 1];
                    totalLength += GeoConverter.HaversineDistance(p1.Lat, p1.Lon, p2.Lat, p2.Lon);
                }
            }

            summary += $"Total length: {totalLength / 1000:F2} km\n";
            summary += "Types:\n";
            foreach (var group in typeGroups.OrderByDescending(g => g.Count()).Take(5))
            {
                summary += $"  {group.Key}: {group.Count()}\n";
            }
            return summary;
        }
    }
}

===== Properties/launchSettings.json =====
{
  "profiles": {
    "Rhino 8 - netcore": {
      "commandName": "Executable",
      "executablePath": "C:\\Program Files\\Rhino 8\\System\\Rhino.exe",
      "commandLineArgs": "/netcore /runscript=\"_Grasshopper\"",
      "environmentVariables": {
        "RHINO_PACKAGE_DIRS": "$(ProjectDir)$(OutputPath)\\"
      }
    },
    "Rhino 8 - netfx": {
      "commandName": "Executable",
      "executablePath": "C:\\Program Files\\Rhino 8\\System\\Rhino.exe",
      "commandLineArgs": "/netfx /runscript=\"_Grasshopper\"",
      "environmentVariables": {
        "RHINO_PACKAGE_DIRS": "$(ProjectDir)$(OutputPath)\\"
      }
    },
    "Rhino 7": {
      "commandName": "Executable",
      "executablePath": "C:\\Program Files\\Rhino 7\\System\\Rhino.exe",
      "commandLineArgs": "/runscript=\"_Grasshopper\"",
    },
  }
}

===== README.md =====
# GeoDataPlugin

===== Services/OpenTopoService.cs =====
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using GeoDataPlugin.Models;

namespace GeoDataPlugin.Services
{
    public class OpenTopoService
    {
        private static readonly HttpClient client = new HttpClient() { Timeout = TimeSpan.FromSeconds(120) };

        // Open Topo Data - FREE, no API key needed!
        private const string OpenTopoDataUrl = "https://api.opentopodata.org/v1/srtm30m";

        // Rate limiting: 1 call per second, max 100 locations per call
        private static DateTime lastCallTime = DateTime.MinValue;
        private const int MaxLocationsPerCall = 100;

        public static async Task<ElevationGrid> GetElevationAsync(GeoBoundingBox bbox, int gridSize = 50)
        {
            try
            {
                // Create grid of points to sample
                var samplePoints = GenerateSampleGrid(bbox, gridSize);

                if (samplePoints.Count == 0)
                {
                    throw new Exception("No sample points generated");
                }

                // Query elevations in batches
                var elevations = new List<double>();

                for (int i = 0; i < samplePoints.Count; i += MaxLocationsPerCall)
                {
                    var batch = samplePoints.Skip(i).Take(MaxLocationsPerCall).ToList();
                    var batchElevations = await QueryElevationBatch(batch);
                    elevations.AddRange(batchElevations);

                    // Rate limiting: wait 1 second between calls
                    if (i + MaxLocationsPerCall < samplePoints.Count)
                    {
                        await Task.Delay(1100); // 1.1 seconds to be safe
                    }
                }

                // Convert to 2D grid
                return ConvertToGrid(elevations, gridSize, bbox);
            }
            catch (Exception ex)
            {
                throw new Exception($"Elevation download failed: {ex.Message}");
            }
        }

        private static List<GeoPoint> GenerateSampleGrid(GeoBoundingBox bbox, int gridSize)
        {
            var points = new List<GeoPoint>();

            double latStep = (bbox.North - bbox.South) / (gridSize - 1);
            double lonStep = (bbox.East - bbox.West) / (gridSize - 1);

            for (int i = 0; i < gridSize; i++)
            {
                for (int j = 0; j < gridSize; j++)
                {
                    double lat = bbox.South + i * latStep;
                    double lon = bbox.West + j * lonStep;
                    points.Add(new GeoPoint(lat, lon));
                }
            }

            return points;
        }

        private static async Task<List<double>> QueryElevationBatch(List<GeoPoint> points)
        {
            try
            {
                // Build locations parameter: "lat1,lon1|lat2,lon2|..."
                var locations = string.Join("|", points.Select(p => $"{p.Lat:F6},{p.Lon:F6}"));

                var url = $"{OpenTopoDataUrl}?locations={locations}";

                var response = await client.GetAsync(url);

                if (!response.IsSuccessStatusCode)
                {
                    throw new Exception($"API returned: {response.StatusCode}");
                }

                var json = await response.Content.ReadAsStringAsync();
                var data = JObject.Parse(json);

                var status = data["status"]?.ToString();
                if (status != "OK")
                {
                    throw new Exception($"API status: {status}");
                }

                var results = data["results"];
                var elevations = new List<double>();

                foreach (var result in results)
                {
                    var elevation = result["elevation"];
                    if (elevation != null && elevation.Type != JTokenType.Null)
                    {
                        elevations.Add(elevation.Value<double>());
                    }
                    else
                    {
                        // No data point - use 0 or interpolate
                        elevations.Add(0.0);
                    }
                }

                return elevations;
            }
            catch (Exception ex)
            {
                throw new Exception($"Elevation query failed: {ex.Message}");
            }
        }

        private static ElevationGrid ConvertToGrid(List<double> elevations, int gridSize, GeoBoundingBox bbox)
        {
            var grid = new double[gridSize, gridSize];

            int index = 0;
            for (int i = 0; i < gridSize; i++)
            {
                for (int j = 0; j < gridSize; j++)
                {
                    if (index < elevations.Count)
                    {
                        grid[i, j] = elevations[index];
                        index++;
                    }
                }
            }

            // Calculate cell size in meters
            double widthMeters = bbox.WidthMeters();
            double heightMeters = bbox.HeightMeters();
            double cellSize = Math.Max(widthMeters, heightMeters) / (gridSize - 1);

            return new ElevationGrid
            {
                Elevations = grid,
                Rows = gridSize,
                Cols = gridSize,
                CellSize = cellSize,
                BoundingBox = bbox
            };
        }

        // Alternative method: Get elevation for single point (useful for other features)
        public static async Task<double?> GetElevationAtPoint(double lat, double lon)
        {
            try
            {
                var url = $"{OpenTopoDataUrl}?locations={lat:F6},{lon:F6}";

                var response = await client.GetAsync(url);
                response.EnsureSuccessStatusCode();

                var json = await response.Content.ReadAsStringAsync();
                var data = JObject.Parse(json);

                var elevation = data["results"]?[0]?["elevation"];
                if (elevation != null && elevation.Type != JTokenType.Null)
                {
                    return elevation.Value<double>();
                }

                return null;
            }
            catch
            {
                return null;
            }
        }
    }
}

===== Services/OverpassService.cs =====
using GeoDataPlugin.Models;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using static GeoDataPlugin.Models.GeoBoundingBox;


namespace GeoDataPlugin.Services
{
    // ask OpenStreetMap for all buildings inside a given area and converts them into usable Building objects.
    // GeoBoundingBox > Overpass API (OpenStreetMap) > JSON data > Building objects (footprints + height)
    public class OverpassService
    {
        private static readonly HttpClient client = new HttpClient();

        // Multiple Overpass API servers for load balancing
        private static readonly string[] OverpassUrls = new[]
        {
            "https://overpass-api.de/api/interpreter",
            "https://overpass.kumi.systems/api/interpreter",
            "https://overpass.openstreetmap.ru/api/interpreter"
        };

        private static int currentServerIndex = 0;


        // get all buildings inside the geographic rectangle
        public static async Task<List<Building>> GetBuildingsAsync(GeoBoundingBox bbox)
        {
            string query = BuildOverpassQuery(bbox);

            // Try up to 3 times with different servers
            for (int attempt = 0; attempt < 3; attempt++)
            {
                try
                {
                    string url = OverpassUrls[currentServerIndex % OverpassUrls.Length];

                    var content = new StringContent($"data={Uri.EscapeDataString(query)}");
                    content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/x-www-form-urlencoded");

                    var response = await client.PostAsync(url, content);

                    if (response.IsSuccessStatusCode)
                    {
                        string json = await response.Content.ReadAsStringAsync();
                        return ParseBuildings(json);
                    }
                    else if ((int)response.StatusCode == 429 || (int)response.StatusCode == 504)
                    {
                        // Rate limited or timeout - try next server
                        currentServerIndex++;

                        if (attempt < 2)
                        {
                            // Wait before retry
                            await Task.Delay(2000 * (attempt + 1));
                            continue;
                        }
                    }

                    throw new Exception($"Server returned: {response.StatusCode}");
                }
                catch (TaskCanceledException)
                {
                    currentServerIndex++;
                    if (attempt < 2)
                    {
                        await Task.Delay(1000);
                        continue;
                    }
                    throw new Exception("Request timeout - try reducing the radius or try again later");
                }
                catch (Exception ex) when (attempt < 2)
                {
                    currentServerIndex++;
                    await Task.Delay(2000);
                    continue;
                }
            }

            throw new Exception("Failed to connect to Overpass API after 3 attempts. The servers may be overloaded. Try again in a few minutes or reduce the search radius.");
        }


        // Overpass QL query to get buildings in bounding box
        // Format: (south, west, north, east)
        private static string BuildOverpassQuery(GeoBoundingBox bbox)
        {
            return $@"
[out:json][timeout:30];
(
  way[""building""]({bbox.South},{bbox.West},{bbox.North},{bbox.East});
);
out body;
>;
out skel qt;";
        }



        // Parses Overpass API JSON response into Building objects
        private static List<Building> ParseBuildings(string json)
        {
            var buildings = new List<Building>();

            try
            {
                var data = JObject.Parse(json);
                var elements = data["elements"];

                if (elements == null)
                {
                    return buildings;
                }

                // Create node lookup
                var nodes = new Dictionary<long, GeoPoint>();
                foreach (var element in elements)
                {
                    if (element["type"]?.ToString() == "node")
                    {
                        long id = element["id"].Value<long>();
                        double lat = element["lat"].Value<double>();
                        double lon = element["lon"].Value<double>();
                        nodes[id] = new GeoPoint(lat, lon);
                    }
                }

                // Parse ways (building footprints)
                // Each way contains an array of node IDs that form the building outline
                foreach (var element in elements)
                {
                    if (element["type"]?.ToString() == "way" && element["tags"] != null)
                    {
                        var tags = element["tags"];
                        if (tags["building"] != null)
                        {
                            var building = new Building
                            {
                                Id = element["id"].ToString(),
                                BuildingType = tags["building"]?.ToString() ?? "yes"
                            };

                            // Parse height
                            if (tags["height"] != null)
                            {
                                string heightStr = tags["height"].ToString().Replace("m", "").Trim();
                                if (double.TryParse(heightStr, out double height))
                                    building.Height = height;
                            }

                            // Parse levels
                            if (tags["building:levels"] != null)
                            {
                                if (int.TryParse(tags["building:levels"].ToString(), out int levels))
                                    building.Levels = levels;
                            }

                            // Get footprint nodes
                            var nodeRefs = element["nodes"];
                            if (nodeRefs != null)
                            {
                                foreach (var nodeRef in nodeRefs)
                                {
                                    long nodeId = nodeRef.Value<long>();
                                    if (nodes.ContainsKey(nodeId))
                                    {
                                        building.Footprint.Add(nodes[nodeId]);
                                    }
                                }
                            }

                            if (building.Footprint.Count >= 3) // Valid polygon
                            {
                                buildings.Add(building);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to parse response: {ex.Message}");
            }


            return buildings;
        }
    }
}

===== Services/StreetsService.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using GeoDataPlugin.Models;

namespace GeoDataPlugin.Services
{
    public class StreetsService
    {
        private static readonly HttpClient client = new HttpClient() { Timeout = TimeSpan.FromSeconds(60) };

        private static readonly string[] OverpassUrls = new[]
        {
            "https://overpass-api.de/api/interpreter",
            "https://overpass.kumi.systems/api/interpreter",
            "https://overpass.openstreetmap.ru/api/interpreter"
        };

        private static int currentServerIndex = 0;

        public static async Task<List<Street>> GetStreetsAsync(GeoBoundingBox bbox, StreetFilter filter = null)
        {
            if (filter == null) filter = StreetFilter.Default;

            string query = BuildStreetsQuery(bbox, filter);

            // Try up to 3 times with different servers
            for (int attempt = 0; attempt < 3; attempt++)
            {
                try
                {
                    string url = OverpassUrls[currentServerIndex % OverpassUrls.Length];

                    var content = new StringContent($"data={Uri.EscapeDataString(query)}");
                    content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/x-www-form-urlencoded");

                    var response = await client.PostAsync(url, content);

                    if (response.IsSuccessStatusCode)
                    {
                        string json = await response.Content.ReadAsStringAsync();
                        return ParseStreets(json);
                    }
                    else if ((int)response.StatusCode == 429 || (int)response.StatusCode == 504)
                    {
                        currentServerIndex++;
                        if (attempt < 2)
                        {
                            await Task.Delay(2000 * (attempt + 1));
                            continue;
                        }
                    }

                    throw new Exception($"Server returned: {response.StatusCode}");
                }
                catch (TaskCanceledException)
                {
                    currentServerIndex++;
                    if (attempt < 2)
                    {
                        await Task.Delay(1000);
                        continue;
                    }
                    throw new Exception("Request timeout - try reducing radius");
                }
                catch (Exception ex) when (attempt < 2)
                {
                    currentServerIndex++;
                    await Task.Delay(2000);
                    continue;
                }
            }

            throw new Exception("Failed to connect after 3 attempts");
        }

        private static string BuildStreetsQuery(GeoBoundingBox bbox, StreetFilter filter)
        {
            var types = new List<string>();

            if (filter.IncludeMotorways) types.Add("\"highway\"=\"motorway\"");
            if (filter.IncludeTrunks) types.Add("\"highway\"=\"trunk\"");
            if (filter.IncludePrimary) types.Add("\"highway\"=\"primary\"");
            if (filter.IncludeSecondary) types.Add("\"highway\"=\"secondary\"");
            if (filter.IncludeTertiary) types.Add("\"highway\"=\"tertiary\"");
            if (filter.IncludeResidential) types.Add("\"highway\"=\"residential\"");
            if (filter.IncludeService) types.Add("\"highway\"=\"service\"");
            if (filter.IncludePedestrian) types.Add("\"highway\"=\"pedestrian\"");
            if (filter.IncludePaths) types.Add("\"highway\"=\"footway\"");

            string typeFilter = string.Join("", types.Select(t => $"way[{t}]({bbox.South},{bbox.West},{bbox.North},{bbox.East});"));

            return $@"
[out:json][timeout:30];
(
  {typeFilter}
);
out body;
>;
out skel qt;";
        }

        private static List<Street> ParseStreets(string json)
        {
            var streets = new List<Street>();

            try
            {
                var data = JObject.Parse(json);
                var elements = data["elements"];

                if (elements == null) return streets;

                // Create node lookup
                var nodes = new Dictionary<long, GeoPoint>();
                foreach (var element in elements)
                {
                    if (element["type"]?.ToString() == "node")
                    {
                        long id = element["id"].Value<long>();
                        double lat = element["lat"].Value<double>();
                        double lon = element["lon"].Value<double>();
                        nodes[id] = new GeoPoint(lat, lon);
                    }
                }

                // Parse ways (streets)
                foreach (var element in elements)
                {
                    if (element["type"]?.ToString() == "way" && element["tags"] != null)
                    {
                        var tags = element["tags"];
                        var highwayType = tags["highway"]?.ToString();

                        if (!string.IsNullOrEmpty(highwayType))
                        {
                            var street = new Street
                            {
                                Id = element["id"].ToString(),
                                Type = highwayType,
                                Name = tags["name"]?.ToString() ?? "Unnamed",
                                Width = 0
                            };

                            // Parse lanes
                            if (tags["lanes"] != null)
                            {
                                if (int.TryParse(tags["lanes"].ToString(), out int lanes))
                                {
                                    street.Lanes = lanes;
                                }
                            }

                            // Parse width
                            if (tags["width"] != null)
                            {
                                string widthStr = tags["width"].ToString().Replace("m", "").Trim();
                                if (double.TryParse(widthStr, System.Globalization.NumberStyles.Any,
                                    System.Globalization.CultureInfo.InvariantCulture, out double width))
                                {
                                    street.Width = width;
                                }
                            }

                            // Estimate width from type if not specified
                            if (street.Width == 0)
                            {
                                street.Width = EstimateStreetWidth(highwayType, street.Lanes);
                            }

                            // Get centerline nodes
                            var nodeRefs = element["nodes"];
                            if (nodeRefs != null)
                            {
                                foreach (var nodeRef in nodeRefs)
                                {
                                    long nodeId = nodeRef.Value<long>();
                                    if (nodes.ContainsKey(nodeId))
                                    {
                                        street.Centerline.Add(nodes[nodeId]);
                                    }
                                }
                            }

                            if (street.Centerline.Count >= 2)
                            {
                                streets.Add(street);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to parse streets: {ex.Message}");
            }

            return streets;
        }

        private static double EstimateStreetWidth(string type, int? lanes)
        {
            // Default widths in meters based on road type
            switch (type.ToLower())
            {
                case "motorway": return lanes.HasValue ? lanes.Value * 3.7 : 15.0;
                case "trunk": return lanes.HasValue ? lanes.Value * 3.5 : 12.0;
                case "primary": return lanes.HasValue ? lanes.Value * 3.5 : 10.0;
                case "secondary": return lanes.HasValue ? lanes.Value * 3.5 : 8.0;
                case "tertiary": return lanes.HasValue ? lanes.Value * 3.0 : 6.0;
                case "residential": return lanes.HasValue ? lanes.Value * 3.0 : 6.0;
                case "service": return 4.0;
                case "pedestrian": return 3.0;
                case "footway": return 2.0;
                case "path": return 1.5;
                default: return 5.0;
            }
        }
    }

    public class StreetFilter
    {
        public bool IncludeMotorways { get; set; }
        public bool IncludeTrunks { get; set; }
        public bool IncludePrimary { get; set; }
        public bool IncludeSecondary { get; set; }
        public bool IncludeTertiary { get; set; }
        public bool IncludeResidential { get; set; }
        public bool IncludeService { get; set; }
        public bool IncludePedestrian { get; set; }
        public bool IncludePaths { get; set; }

        public static StreetFilter Default => new StreetFilter
        {
            IncludeMotorways = true,
            IncludeTrunks = true,
            IncludePrimary = true,
            IncludeSecondary = true,
            IncludeTertiary = true,
            IncludeResidential = true,
            IncludeService = false,  // Too many, usually not needed
            IncludePedestrian = false,
            IncludePaths = false
        };

        public static StreetFilter All => new StreetFilter
        {
            IncludeMotorways = true,
            IncludeTrunks = true,
            IncludePrimary = true,
            IncludeSecondary = true,
            IncludeTertiary = true,
            IncludeResidential = true,
            IncludeService = true,
            IncludePedestrian = true,
            IncludePaths = true
        };
    }
}

===== Utils/GeoConverter.cs =====
using GeoDataPlugin.Models;
using Rhino.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GeoDataPlugin.Utils
{
    /// <summary>
    /// Provides static methods for converting between geographic coordinates and local Cartesian coordinates,
    /// calculating distances, and creating geographic bounding boxes.
    /// </summary>
    /// <remarks>The GeoConverter class is intended for use with small geographic areas where the effects of
    /// Earth's curvature can be approximated using simple projections. All methods assume coordinates are specified in
    /// decimal degrees and distances in meters. The class is thread-safe as it contains only static methods and does
    /// not maintain any internal state.</remarks>
    public class GeoConverter
    {
        // average radius of Earth in meters
        private const double EarthRadius = 6371000;

        // GeoToLocal Converts lat/lon to local XY coordinates using a reference origin 
        public static Point3d GeoToLocal(double lat, double lon, double originLat, double originLon)
        {
            // Simple equirectangular projection (good for small areas)
            double x = (lon - originLon) * Math.Cos(originLat * Math.PI / 180.0) * EarthRadius * Math.PI / 180.0;
            double y = (lat - originLat) * EarthRadius * Math.PI / 180.0;

            return new Point3d(x, y, 0);
        }

        // Haversine distance between two points in meters
        // returns a real-world distance in meters from given lat/lon of 2 points
        public static double HaversineDistance(double lat1, double lon1, double lat2, double lon2)
        {
            double dLat = (lat2 - lat1) * Math.PI / 180.0;
            double dLon = (lon2 - lon1) * Math.PI / 180.0;

            double a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                      Math.Cos(lat1 * Math.PI / 180.0) * Math.Cos(lat2 * Math.PI / 180.0) *
                      Math.Sin(dLon / 2) * Math.Sin(dLon / 2);

            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));

            return EarthRadius * c;
        }
        // Create a bounding box around a center point with radius in meters
        // used by api/s to get data within a rectangle
        public static GeoBoundingBox CreateBBox(double centerLat, double centerLon, double radiusMeters)
        {
            double latDelta = (radiusMeters / EarthRadius) * (180.0 / Math.PI);
            double lonDelta = (radiusMeters / (EarthRadius * Math.Cos(centerLat * Math.PI / 180.0))) * (180.0 / Math.PI);

            return new GeoBoundingBox(
                centerLat - latDelta,
                centerLon - lonDelta,
                centerLat + latDelta,
                centerLon + lonDelta
            );
        }
    }
}

===== Utils/MeshBuilder.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using Rhino.Geometry;
using GeoDataPlugin.Models;
namespace GeoDataPlugin.Utils
{
    public static class MeshBuilder
    {
        // Build terrain mesh from elevation grid
        public static Mesh BuildTerrainMesh(double[,] elevations, double cellSize, Point3d origin)
        {
            int rows = elevations.GetLength(0);
            int cols = elevations.GetLength(1);

            var mesh = new Mesh();

            // Add vertices
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    double x = origin.X + j * cellSize;
                    double y = origin.Y + i * cellSize;
                    double z = elevations[i, j];

                    mesh.Vertices.Add(x, y, z);
                }
            }

            // Add faces
            for (int i = 0; i < rows - 1; i++)
            {
                for (int j = 0; j < cols - 1; j++)
                {
                    int v1 = i * cols + j;
                    int v2 = i * cols + (j + 1);
                    int v3 = (i + 1) * cols + (j + 1);
                    int v4 = (i + 1) * cols + j;

                    mesh.Faces.AddFace(v1, v2, v3, v4);
                }
            }

            mesh.Normals.ComputeNormals();
            mesh.Compact();

            return mesh;
        }

        // Build building breps from footprints
        public static List<Brep> BuildBuildingBreps(List<Building> buildings, double originLat, double originLon)
        {
            var breps = new List<Brep>();

            // Process in parallel for speed
            var results = new Brep[buildings.Count];

            System.Threading.Tasks.Parallel.For(0, buildings.Count, i =>
            {
                try
                {
                    results[i] = CreateBuildingBrepFast(buildings[i], originLat, originLon);
                }
                catch
                {
                    results[i] = null;
                }
            });

            // Collect valid results
            foreach (var brep in results)
            {
                if (brep != null && brep.IsValid)
                {
                    breps.Add(brep);
                }
            }

            return breps;
        }        
        private static Brep CreateBuildingBrepFast(Building building, double originLat, double originLon)
        {
            // Convert and clean points
            var points = new List<Point3d>(building.Footprint.Count);

            foreach (var geoPoint in building.Footprint)
            {
                points.Add(GeoConverter.GeoToLocal(geoPoint.Lat, geoPoint.Lon, originLat, originLon));
            }

            if (points.Count < 3) return null;

            // Remove duplicates in one pass
            var cleaned = new List<Point3d>(points.Count) { points[0] };
            for (int i = 1; i < points.Count; i++)
            {
                if (points[i].DistanceTo(cleaned[cleaned.Count - 1]) > 0.01)
                {
                    cleaned.Add(points[i]);
                }
            }

            // Ensure closed
            if (cleaned[0].DistanceTo(cleaned[cleaned.Count - 1]) > 0.01)
            {
                cleaned.Add(cleaned[0]);
            }

            if (cleaned.Count < 4) return null;

            double height = building.GetHeight();
            if (height <= 0) height = 10.0;

            // Single fast method: Loft
            try
            {
                var bottomCurve = new Polyline(cleaned).ToNurbsCurve();
                if (bottomCurve == null || !bottomCurve.IsClosed) return null;

                // Create top curve
                var topCurve = (Curve)bottomCurve.Duplicate();
                topCurve.Transform(Transform.Translation(0, 0, height));

                // Loft (fastest method)
                var lofted = Brep.CreateFromLoft(
                    new[] { bottomCurve, topCurve },
                    Point3d.Unset,
                    Point3d.Unset,
                    LoftType.Straight,
                    false
                );

                if (lofted != null && lofted.Length > 0)
                {
                    var brep = lofted[0].CapPlanarHoles(0.01);
                    return brep;
                }
            }
            catch
            {
                // If loft fails, skip (don't waste time on fallbacks)
                return null;
            }

            return null;
        }
    }
}

